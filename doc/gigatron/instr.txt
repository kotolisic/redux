------------------------------------------------------------------------
ФОРМАТ ОПКОДА
------------------------------------------------------------------------

    [15 14 13] [12 11 10] [9 8] [7 ... 0]
     op         mode       bus   d

------------------------------------------------------------------------
НАБОР ИНСТРУКЦИИ
------------------------------------------------------------------------

     op | Мнем. | Описание
    ----+-------+---
      0 | LD    | Копирование операнда
      1 | AND   | Логическое И
      2 | OR    | Логическое ИЛИ
      3 | XOR   | Исключающее ИЛИ
      4 | ADD   | Сложение без переноса
      5 | SUB   | Вычитание без переноса
      6 | ST    | Запись в память
      7 | BRxx  | Условные и безусловные переходы

------------------------------------------------------------------------
АРИФМЕТИКО-ЛОГИЧЕСКОЕ УСТРОЙСТВО (LOAD, AND, OR, XOR, ADD, SUB)
------------------------------------------------------------------------

    Куда записывать (dst) указывается через `mode`:

        mode    0 1 2 3 | 4 5 | 6 7
        dst        ac   | x y | out

    Первый операнд всегда ac.
    Второй операнд (src) указывается через `bus`:

        00 | d
        01 | память, адрес указывается через mode:

             mode  0   1    2     3    4  5  6     7
                  [d] [x] [y,d] [y,x]    [d]    [y,x++]

        10 | ac
        11 | inReg

    Если был указан `mode` = 6, то X постинкрементируется


------------------------------------------------------------------------
ЗАПИСЬ В ПАМЯТЬ (ST)
------------------------------------------------------------------------

    Операнд для записи
    bus     0  1  2  3
            d  ?  ac inreg

    Куда пишется
    mode   0   1    2     3    4  5  6     7
          [d] [x] [y,d] [y,x]    [d]    [y,x++]   

    Если mode=4, то также операнд пишется в X
         mode=5, то также операнд пишется в Y


------------------------------------------------------------------------
УСЛОВНЫЕ И БЕЗУСЛОВНЫЕ ПЕРЕХОДЫ (BRxx)
------------------------------------------------------------------------

    mode
    0   JMP Переход по адресу (y,<offset>)
    1   BGT  > 
    2   BLT  <
    3   BNE !=
    4   BEQ ==
    5   BGE >=
    6   BLE <=
    7   BRA Переход по адресу (PC[15:8],<offset>)

    bus offset
    00  d       по указанному смещению
    01  ram[d]  по адресу, записанному в zeropage[d]
    10  ac      по аккумулятору
    11  inReg   по адресу в inreg

    Есть одна особенность. Сравнения идут

        ~ac[7], ac[6:0] и числа $80

    Пример:

        BLT, ac=$05, значит ac'=$85 и $85 < $80? Нет.
        При AC=$05, BLT не сработает.

        Зато BLT сработает при ac=$FE, т.к. ac'=$7E, а $7E < $80

    Почему так работает? Допустим, сравним числа 3 и 7. Вычтем 3 - 7 = -4.
    Число является отрицательным, ac=$FC. А так как это отрицательное число,
    то развернем старший бит и проверим, что оно меньше чем $80. Если да, то
    значит, что число реально было отрицательное, т.к. если бы число было больше
    или равно $80, то это бы значило, что старший бит был бы 0, что сигнализует
    о положительном числе. Если число 0, то все равно получится $80, которое
    равно $80, а значит, что числа равны.
